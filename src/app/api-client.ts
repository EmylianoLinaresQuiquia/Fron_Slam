//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface IApiClient {
    /**
     * Obtiene la lista de todas las categorías con sus subcategorías.
     * @return OK
     */
    categoriaAll(): Observable<Categoria[]>;
    /**
     * Agrega una nueva categoría.
     * @param body (optional)
     * @return Created
     */
    categoriaPOST(body?: Categoria | undefined): Observable<Categoria>;
    /**
     * Filtra los productos según los parámetros proporcionados.
     * @param nombre (optional) Filtro: nombre del producto
     * @param precioMin (optional) Filtro: precio mínimo
     * @param precioMax (optional) Filtro: precio máximo
     * @param categoriaId (optional) Filtro: categoría
     * @param subcategoriaId (optional) Filtro: subcategoría
     * @param minCalificacion (optional) Filtro: calificación mínima
     * @return OK
     */
    filtrar(nombre?: string | undefined, precioMin?: number | undefined, precioMax?: number | undefined, categoriaId?: number | undefined, subcategoriaId?: number | undefined, minCalificacion?: number | undefined): Observable<CategoriaFiltrado[]>;
    /**
     * Edita una categoría existente.
     * @param body (optional)
     * @return OK
     */
    categoriaPUT(id: number, body?: Categoria | undefined): Observable<void>;
    /**
     * Elimina una categoría existente.
     * @return OK
     */
    categoriaDELETE(id: number): Observable<void>;
    /**
     * Crea una factura para un pedido específico.
     * @return OK
     */
    facturaPOST(idPedido: number): Observable<any>;
    /**
     * Ver una factura y sus detalles.
     * @return OK
     */
    facturaGET(idFactura: number): Observable<any>;
    /**
     * Lista todos los métodos de pago.
     * @return OK
     */
    metodoPagoAll(): Observable<MetodoPago[]>;
    /**
     * Agrega un nuevo método de pago.
     * @param body (optional)
     * @return OK
     */
    metodoPago(body?: MetodoPago | undefined): Observable<any>;
    /**
     * Registra un pago para un pedido.
     * @param body (optional)
     * @return OK
     */
    pago(body?: RegistrarPagoRequest | undefined): Observable<any>;
    /**
     * Lista los pagos realizados para un pedido.
     * @return OK
     */
    pagoAll(idPedido: number): Observable<Pago[]>;
    /**
     * Lista los pedidos según el estado (opcional).
     * @param estado (optional)
     * @return OK
     */
    pedidoAll(estado?: string | undefined): Observable<Pedido[]>;
    /**
     * Crea un nuevo pedido.
     * @param body (optional)
     * @return OK
     */
    pedidoPOST(body?: CrearPedidoRequest | undefined): Observable<any>;
    /**
     * Obtiene el detalle de un pedido.
     * @return OK
     */
    pedidoGET(id: number): Observable<any>;
    /**
     * Cambia el estado de un pedido.
     * @param body (optional)
     * @return OK
     */
    estado(id: number, body?: CambiarEstadoRequest | undefined): Observable<any>;
    /**
     * Cancela un pedido.
     * @param body (optional)
     * @return OK
     */
    cancelar(id: number, body?: CancelarPedidoRequest | undefined): Observable<any>;
    /**
     * Consulta el historial de un pedido.
     * @return OK
     */
    historial(id: number): Observable<HistorialEstadoPedido[]>;
    /**
     * Marca un pedido como cancelado (soft delete).
     * @return OK
     */
    pedidoDELETE(idPedido: number): Observable<void>;
    /**
     * @param estado (optional)
     * @return OK
     */
    usuario(idUsuario: number, estado?: string | undefined): Observable<Pedido[]>;
    /**
     * @return OK
     */
    productoDELETE(id: number): Observable<any>;
    /**
     * @return OK
     */
    productoGET(id: number): Observable<Productoid>;
    /**
     * @param id_producto (optional) Identificador único del producto.
     * @param nombre (optional) Nombre del producto.
     * @param descripcion (optional) Descripción detallada del producto.
     * @param categoria_id (optional) Identificador de la categoría a la que pertenece el producto.
     * @param subcategoria_id (optional) Identificador de la subcategoría a la que pertenece el producto.
     * @param marca (optional) Marca del producto.
     * @param precio (optional) Precio del producto.
     * @param cantidad_disponible (optional) Cantidad disponible en inventario.
     * @param unidad_medida (optional) Unidad de medida del producto.
     * @param imagen_archivo (optional) Imagen del producto como archivo. Se usa para actualizar la imagen.
     * @param imagen_url (optional) URL existente de la imagen. Se usa si no se proporciona un nuevo archivo.
     * @param activo (optional) Indica si el producto está activo.
     * @return OK
     */
    productoPUT(id_producto?: number | undefined, nombre?: string | undefined, descripcion?: string | undefined, categoria_id?: number | undefined, subcategoria_id?: number | undefined, marca?: string | undefined, precio?: number | undefined, cantidad_disponible?: number | undefined, unidad_medida?: string | undefined, imagen_archivo?: FileParameter | undefined, imagen_url?: string | undefined, activo?: boolean | undefined): Observable<any>;
    /**
     * @param id_producto (optional) Identificador único del producto.
     * @param nombre (optional) Nombre del producto.
     * @param descripcion (optional) Descripción detallada del producto.
     * @param categoria_id (optional) Identificador de la categoría a la que pertenece el producto.
     * @param subcategoria_id (optional) Identificador de la subcategoría a la que pertenece el producto.
     * @param marca (optional) Marca del producto.
     * @param precio (optional) Precio del producto.
     * @param cantidad_disponible (optional) Cantidad disponible en inventario.
     * @param unidad_medida (optional) Unidad de medida del producto.
     * @param imagen_url (optional) Imagen del producto.
     * @param fecha_agregado (optional) Fecha en que el producto fue agregado al inventario.
     * @param activo (optional) Indica si el producto está activo.
     * @return OK
     */
    productoPOST(id_producto?: number | undefined, nombre?: string | undefined, descripcion?: string | undefined, categoria_id?: number | undefined, subcategoria_id?: number | undefined, marca?: string | undefined, precio?: number | undefined, cantidad_disponible?: number | undefined, unidad_medida?: string | undefined, imagen_url?: FileParameter | undefined, fecha_agregado?: Date | undefined, activo?: boolean | undefined): Observable<any>;
    /**
     * @return OK
     */
    productoAll(): Observable<Productolist[]>;
    /**
     * @param productos (optional)
     * @return OK
     */
    insertarMultiplesProductos(productos?: Producto[] | undefined): Observable<any>;
    /**
     * Obtiene el pedido más reciente realizado en el sistema.
     * @return OK
     */
    pedidoReciente(): Observable<PedidoReciente>;
    /**
     * Obtiene un resumen de ventas entre dos fechas.
     * @param fechaInicio (optional)
     * @param fechaFin (optional)
     * @return OK
     */
    resumenVentas(fechaInicio?: Date | undefined, fechaFin?: Date | undefined): Observable<ResumenVentas[]>;
    /**
     * Obtiene los productos más vendidos en un rango de fechas.
     * @param fechaInicio (optional)
     * @param fechaFin (optional)
     * @param limite (optional)
     * @return OK
     */
    productosMasVendidos(fechaInicio?: Date | undefined, fechaFin?: Date | undefined, limite?: number | undefined): Observable<ProductoMasVendido[]>;
    /**
     * Obtiene un resumen de ventas por categoría en un rango de fechas.
     * @param fechaInicio (optional)
     * @param fechaFin (optional)
     * @return OK
     */
    ventasPorCategoria(fechaInicio?: Date | undefined, fechaFin?: Date | undefined): Observable<VentasPorCategoria[]>;
    /**
     * Obtiene los clientes más frecuentes del sistema.
     * @param limite (optional)
     * @return OK
     */
    clientesFrecuentes(limite?: number | undefined): Observable<ClienteFrecuente[]>;
    /**
     * Obtiene las notificaciones generadas en el sistema.
     * @return OK
     */
    notificaciones(): Observable<void>;
    /**
     * @param body (optional)
     * @return OK
     */
    rolPOST(body?: Rol | undefined): Observable<any>;
    /**
     * @param body (optional)
     * @return OK
     */
    rolPUT(id: number, body?: Rol | undefined): Observable<any>;
    /**
     * @return OK
     */
    rolDELETE(id: number): Observable<any>;
    /**
     * Obtiene la lista de todas las subcategorías.
     * @return OK
     */
    subcategoriaAll(): Observable<Subcategoria[]>;
    /**
     * Agrega una nueva subcategoría.
     * @param body (optional)
     * @return Created
     */
    subcategoriaPOST(body?: Subcategoria | undefined): Observable<Subcategoria>;
    /**
     * Edita una subcategoría existente.
     * @param body (optional)
     * @return OK
     */
    subcategoriaPUT(id: number, body?: Subcategoria | undefined): Observable<any>;
    /**
     * Elimina una subcategoría existente.
     * @return OK
     */
    subcategoriaDELETE(id: number): Observable<any>;
    /**
     * @param body (optional)
     * @return OK
     */
    registrar(body?: UsuarioPost | undefined): Observable<any>;
    /**
     * @param body (optional)
     * @return OK
     */
    iniciarSesion(body?: UsuarioLogin | undefined): Observable<any>;
    /**
     * @param body (optional)
     * @return OK
     */
    editarUsuario(body?: UsuarioEditar | undefined): Observable<any>;
    /**
     * @return OK
     */
    eliminarUsuario(idUsuario: number): Observable<any>;
    /**
     * @param body (optional)
     * @return OK
     */
    registrarActividad(body?: RegistrarActividadRequest | undefined): Observable<any>;
    /**
     * @return OK
     */
    consultarAuditoria(idUsuario: number): Observable<any>;
    /**
     * @param body (optional)
     * @return OK
     */
    solicitarRecuperacion(body?: SolicitudRecuperacion | undefined): Observable<any>;
    /**
     * @param body (optional)
     * @return OK
     */
    cambiarContrasena(body?: CambioContrasena | undefined): Observable<any>;
}

@Injectable()
export class ApiClient implements IApiClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
      this.http = http;
      this.baseUrl = baseUrl ?? "https://back-slam-9063874ff5f1.herokuapp.com"; // Cambia por tu URL real
  }

    /**
     * Obtiene la lista de todas las categorías con sus subcategorías.
     * @return OK
     */
    categoriaAll(): Observable<Categoria[]> {
        let url_ = this.baseUrl + "/api/Categoria";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCategoriaAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCategoriaAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Categoria[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Categoria[]>;
        }));
    }

    protected processCategoriaAll(response: HttpResponseBase): Observable<Categoria[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Categoria.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Agrega una nueva categoría.
     * @param body (optional)
     * @return Created
     */
    categoriaPOST(body?: Categoria | undefined): Observable<Categoria> {
        let url_ = this.baseUrl + "/api/Categoria";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCategoriaPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCategoriaPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Categoria>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Categoria>;
        }));
    }

    protected processCategoriaPOST(response: HttpResponseBase): Observable<Categoria> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = Categoria.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Filtra los productos según los parámetros proporcionados.
     * @param nombre (optional) Filtro: nombre del producto
     * @param precioMin (optional) Filtro: precio mínimo
     * @param precioMax (optional) Filtro: precio máximo
     * @param categoriaId (optional) Filtro: categoría
     * @param subcategoriaId (optional) Filtro: subcategoría
     * @param minCalificacion (optional) Filtro: calificación mínima
     * @return OK
     */
    filtrar(nombre?: string | undefined, precioMin?: number | undefined, precioMax?: number | undefined, categoriaId?: number | undefined, subcategoriaId?: number | undefined, minCalificacion?: number | undefined): Observable<CategoriaFiltrado[]> {
        let url_ = this.baseUrl + "/api/Categoria/filtrar?";
        if (nombre === null)
            throw new Error("The parameter 'nombre' cannot be null.");
        else if (nombre !== undefined)
            url_ += "nombre=" + encodeURIComponent("" + nombre) + "&";
        if (precioMin === null)
            throw new Error("The parameter 'precioMin' cannot be null.");
        else if (precioMin !== undefined)
            url_ += "precioMin=" + encodeURIComponent("" + precioMin) + "&";
        if (precioMax === null)
            throw new Error("The parameter 'precioMax' cannot be null.");
        else if (precioMax !== undefined)
            url_ += "precioMax=" + encodeURIComponent("" + precioMax) + "&";
        if (categoriaId === null)
            throw new Error("The parameter 'categoriaId' cannot be null.");
        else if (categoriaId !== undefined)
            url_ += "categoriaId=" + encodeURIComponent("" + categoriaId) + "&";
        if (subcategoriaId === null)
            throw new Error("The parameter 'subcategoriaId' cannot be null.");
        else if (subcategoriaId !== undefined)
            url_ += "subcategoriaId=" + encodeURIComponent("" + subcategoriaId) + "&";
        if (minCalificacion === null)
            throw new Error("The parameter 'minCalificacion' cannot be null.");
        else if (minCalificacion !== undefined)
            url_ += "minCalificacion=" + encodeURIComponent("" + minCalificacion) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFiltrar(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFiltrar(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CategoriaFiltrado[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CategoriaFiltrado[]>;
        }));
    }

    protected processFiltrar(response: HttpResponseBase): Observable<CategoriaFiltrado[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CategoriaFiltrado.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Edita una categoría existente.
     * @param body (optional)
     * @return OK
     */
    categoriaPUT(id: number, body?: Categoria | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Categoria/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCategoriaPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCategoriaPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCategoriaPUT(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Elimina una categoría existente.
     * @return OK
     */
    categoriaDELETE(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/Categoria/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCategoriaDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCategoriaDELETE(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCategoriaDELETE(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Crea una factura para un pedido específico.
     * @return OK
     */
    facturaPOST(idPedido: number): Observable<any> {
        let url_ = this.baseUrl + "/api/Factura/{idPedido}";
        if (idPedido === undefined || idPedido === null)
            throw new Error("The parameter 'idPedido' must be defined.");
        url_ = url_.replace("{idPedido}", encodeURIComponent("" + idPedido));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFacturaPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFacturaPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processFacturaPOST(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;

            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Ver una factura y sus detalles.
     * @return OK
     */
    facturaGET(idFactura: number): Observable<any> {
        let url_ = this.baseUrl + "/api/Factura/{idFactura}";
        if (idFactura === undefined || idFactura === null)
            throw new Error("The parameter 'idFactura' must be defined.");
        url_ = url_.replace("{idFactura}", encodeURIComponent("" + idFactura));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFacturaGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFacturaGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processFacturaGET(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;

            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Lista todos los métodos de pago.
     * @return OK
     */
    metodoPagoAll(): Observable<MetodoPago[]> {
        let url_ = this.baseUrl + "/api/MetodoPago";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMetodoPagoAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMetodoPagoAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MetodoPago[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MetodoPago[]>;
        }));
    }

    protected processMetodoPagoAll(response: HttpResponseBase): Observable<MetodoPago[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MetodoPago.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Agrega un nuevo método de pago.
     * @param body (optional)
     * @return OK
     */
    metodoPago(body?: MetodoPago | undefined): Observable<any> {
        let url_ = this.baseUrl + "/api/MetodoPago";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMetodoPago(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMetodoPago(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processMetodoPago(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;

            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Registra un pago para un pedido.
     * @param body (optional)
     * @return OK
     */
    pago(body?: RegistrarPagoRequest | undefined): Observable<any> {
        let url_ = this.baseUrl + "/api/Pago";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPago(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPago(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processPago(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;

            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Lista los pagos realizados para un pedido.
     * @return OK
     */
    pagoAll(idPedido: number): Observable<Pago[]> {
        let url_ = this.baseUrl + "/api/Pago/{idPedido}";
        if (idPedido === undefined || idPedido === null)
            throw new Error("The parameter 'idPedido' must be defined.");
        url_ = url_.replace("{idPedido}", encodeURIComponent("" + idPedido));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPagoAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPagoAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Pago[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Pago[]>;
        }));
    }

    protected processPagoAll(response: HttpResponseBase): Observable<Pago[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Pago.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Lista los pedidos según el estado (opcional).
     * @param estado (optional)
     * @return OK
     */
    pedidoAll(estado?: string | undefined): Observable<Pedido[]> {
        let url_ = this.baseUrl + "/api/Pedido?";
        if (estado === null)
            throw new Error("The parameter 'estado' cannot be null.");
        else if (estado !== undefined)
            url_ += "estado=" + encodeURIComponent("" + estado) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPedidoAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPedidoAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Pedido[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Pedido[]>;
        }));
    }

    protected processPedidoAll(response: HttpResponseBase): Observable<Pedido[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Pedido.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Crea un nuevo pedido.
     * @param body (optional)
     * @return OK
     */
    pedidoPOST(body?: CrearPedidoRequest | undefined): Observable<any> {
        let url_ = this.baseUrl + "/api/Pedido";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPedidoPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPedidoPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processPedidoPOST(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;

            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene el detalle de un pedido.
     * @return OK
     */
    pedidoGET(id: number): Observable<any> {
        let url_ = this.baseUrl + "/api/Pedido/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPedidoGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPedidoGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processPedidoGET(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;

            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Cambia el estado de un pedido.
     * @param body (optional)
     * @return OK
     */
    estado(id: number, body?: CambiarEstadoRequest | undefined): Observable<any> {
        let url_ = this.baseUrl + "/api/Pedido/{id}/estado";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEstado(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEstado(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processEstado(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;

            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Cancela un pedido.
     * @param body (optional)
     * @return OK
     */
    cancelar(id: number, body?: CancelarPedidoRequest | undefined): Observable<any> {
        let url_ = this.baseUrl + "/api/Pedido/{id}/cancelar";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancelar(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancelar(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processCancelar(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;

            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Consulta el historial de un pedido.
     * @return OK
     */
    historial(id: number): Observable<HistorialEstadoPedido[]> {
        let url_ = this.baseUrl + "/api/Pedido/{id}/historial";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHistorial(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHistorial(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HistorialEstadoPedido[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HistorialEstadoPedido[]>;
        }));
    }

    protected processHistorial(response: HttpResponseBase): Observable<HistorialEstadoPedido[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(HistorialEstadoPedido.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Marca un pedido como cancelado (soft delete).
     * @return OK
     */
    pedidoDELETE(idPedido: number): Observable<void> {
        let url_ = this.baseUrl + "/api/Pedido/{idPedido}";
        if (idPedido === undefined || idPedido === null)
            throw new Error("The parameter 'idPedido' must be defined.");
        url_ = url_.replace("{idPedido}", encodeURIComponent("" + idPedido));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPedidoDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPedidoDELETE(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPedidoDELETE(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param estado (optional)
     * @return OK
     */
    usuario(idUsuario: number, estado?: string | undefined): Observable<Pedido[]> {
        let url_ = this.baseUrl + "/api/Pedido/usuario/{idUsuario}?";
        if (idUsuario === undefined || idUsuario === null)
            throw new Error("The parameter 'idUsuario' must be defined.");
        url_ = url_.replace("{idUsuario}", encodeURIComponent("" + idUsuario));
        if (estado === null)
            throw new Error("The parameter 'estado' cannot be null.");
        else if (estado !== undefined)
            url_ += "estado=" + encodeURIComponent("" + estado) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUsuario(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUsuario(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Pedido[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Pedido[]>;
        }));
    }

    protected processUsuario(response: HttpResponseBase): Observable<Pedido[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Pedido.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    productoDELETE(id: number): Observable<any> {
        let url_ = this.baseUrl + "/api/Producto/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProductoDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProductoDELETE(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processProductoDELETE(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;

            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    productoGET(id: number): Observable<Productoid> {
        let url_ = this.baseUrl + "/api/Producto/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProductoGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProductoGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Productoid>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Productoid>;
        }));
    }

    protected processProductoGET(response: HttpResponseBase): Observable<Productoid> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Productoid.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;

            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id_producto (optional) Identificador único del producto.
     * @param nombre (optional) Nombre del producto.
     * @param descripcion (optional) Descripción detallada del producto.
     * @param categoria_id (optional) Identificador de la categoría a la que pertenece el producto.
     * @param subcategoria_id (optional) Identificador de la subcategoría a la que pertenece el producto.
     * @param marca (optional) Marca del producto.
     * @param precio (optional) Precio del producto.
     * @param cantidad_disponible (optional) Cantidad disponible en inventario.
     * @param unidad_medida (optional) Unidad de medida del producto.
     * @param imagen_archivo (optional) Imagen del producto como archivo. Se usa para actualizar la imagen.
     * @param imagen_url (optional) URL existente de la imagen. Se usa si no se proporciona un nuevo archivo.
     * @param activo (optional) Indica si el producto está activo.
     * @return OK
     */
    productoPUT(id_producto?: number | undefined, nombre?: string | undefined, descripcion?: string | undefined, categoria_id?: number | undefined, subcategoria_id?: number | undefined, marca?: string | undefined, precio?: number | undefined, cantidad_disponible?: number | undefined, unidad_medida?: string | undefined, imagen_archivo?: FileParameter | undefined, imagen_url?: string | undefined, activo?: boolean | undefined): Observable<any> {
        let url_ = this.baseUrl + "/api/Producto";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (id_producto === null || id_producto === undefined)
            throw new Error("The parameter 'id_producto' cannot be null.");
        else
            content_.append("id_producto", id_producto.toString());
        if (nombre === null || nombre === undefined)
            throw new Error("The parameter 'nombre' cannot be null.");
        else
            content_.append("nombre", nombre.toString());
        if (descripcion === null || descripcion === undefined)
            throw new Error("The parameter 'descripcion' cannot be null.");
        else
            content_.append("descripcion", descripcion.toString());
        if (categoria_id === null || categoria_id === undefined)
            throw new Error("The parameter 'categoria_id' cannot be null.");
        else
            content_.append("categoria_id", categoria_id.toString());
        if (subcategoria_id === null || subcategoria_id === undefined)
            throw new Error("The parameter 'subcategoria_id' cannot be null.");
        else
            content_.append("subcategoria_id", subcategoria_id.toString());
        if (marca === null || marca === undefined)
            throw new Error("The parameter 'marca' cannot be null.");
        else
            content_.append("marca", marca.toString());
        if (precio === null || precio === undefined)
            throw new Error("The parameter 'precio' cannot be null.");
        else
            content_.append("precio", precio.toString());
        if (cantidad_disponible === null || cantidad_disponible === undefined)
            throw new Error("The parameter 'cantidad_disponible' cannot be null.");
        else
            content_.append("cantidad_disponible", cantidad_disponible.toString());
        if (unidad_medida === null || unidad_medida === undefined)
            throw new Error("The parameter 'unidad_medida' cannot be null.");
        else
            content_.append("unidad_medida", unidad_medida.toString());
        if (imagen_archivo === null || imagen_archivo === undefined)
            throw new Error("The parameter 'imagen_archivo' cannot be null.");
        else
            content_.append("imagen_archivo", imagen_archivo.data, imagen_archivo.fileName ? imagen_archivo.fileName : "imagen_archivo");
        if (imagen_url === null || imagen_url === undefined)
            throw new Error("The parameter 'imagen_url' cannot be null.");
        else
            content_.append("imagen_url", imagen_url.toString());
        if (activo === null || activo === undefined)
            throw new Error("The parameter 'activo' cannot be null.");
        else
            content_.append("activo", activo.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProductoPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProductoPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processProductoPUT(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;

            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id_producto (optional) Identificador único del producto.
     * @param nombre (optional) Nombre del producto.
     * @param descripcion (optional) Descripción detallada del producto.
     * @param categoria_id (optional) Identificador de la categoría a la que pertenece el producto.
     * @param subcategoria_id (optional) Identificador de la subcategoría a la que pertenece el producto.
     * @param marca (optional) Marca del producto.
     * @param precio (optional) Precio del producto.
     * @param cantidad_disponible (optional) Cantidad disponible en inventario.
     * @param unidad_medida (optional) Unidad de medida del producto.
     * @param imagen_url (optional) Imagen del producto.
     * @param fecha_agregado (optional) Fecha en que el producto fue agregado al inventario.
     * @param activo (optional) Indica si el producto está activo.
     * @return OK
     */
    productoPOST(id_producto?: number | undefined, nombre?: string | undefined, descripcion?: string | undefined, categoria_id?: number | undefined, subcategoria_id?: number | undefined, marca?: string | undefined, precio?: number | undefined, cantidad_disponible?: number | undefined, unidad_medida?: string | undefined, imagen_url?: FileParameter | undefined, fecha_agregado?: Date | undefined, activo?: boolean | undefined): Observable<any> {
        let url_ = this.baseUrl + "/api/Producto";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (id_producto === null || id_producto === undefined)
            throw new Error("The parameter 'id_producto' cannot be null.");
        else
            content_.append("id_producto", id_producto.toString());
        if (nombre === null || nombre === undefined)
            throw new Error("The parameter 'nombre' cannot be null.");
        else
            content_.append("nombre", nombre.toString());
        if (descripcion === null || descripcion === undefined)
            throw new Error("The parameter 'descripcion' cannot be null.");
        else
            content_.append("descripcion", descripcion.toString());
        if (categoria_id === null || categoria_id === undefined)
            throw new Error("The parameter 'categoria_id' cannot be null.");
        else
            content_.append("categoria_id", categoria_id.toString());
        if (subcategoria_id === null || subcategoria_id === undefined)
            throw new Error("The parameter 'subcategoria_id' cannot be null.");
        else
            content_.append("subcategoria_id", subcategoria_id.toString());
        if (marca === null || marca === undefined)
            throw new Error("The parameter 'marca' cannot be null.");
        else
            content_.append("marca", marca.toString());
        if (precio === null || precio === undefined)
            throw new Error("The parameter 'precio' cannot be null.");
        else
            content_.append("precio", precio.toString());
        if (cantidad_disponible === null || cantidad_disponible === undefined)
            throw new Error("The parameter 'cantidad_disponible' cannot be null.");
        else
            content_.append("cantidad_disponible", cantidad_disponible.toString());
        if (unidad_medida === null || unidad_medida === undefined)
            throw new Error("The parameter 'unidad_medida' cannot be null.");
        else
            content_.append("unidad_medida", unidad_medida.toString());
        if (imagen_url === null || imagen_url === undefined)
            throw new Error("The parameter 'imagen_url' cannot be null.");
        else
            content_.append("imagen_url", imagen_url.data, imagen_url.fileName ? imagen_url.fileName : "imagen_url");
        if (fecha_agregado === null || fecha_agregado === undefined)
            throw new Error("The parameter 'fecha_agregado' cannot be null.");
        else
            content_.append("fecha_agregado", fecha_agregado.toJSON());
        if (activo === null || activo === undefined)
            throw new Error("The parameter 'activo' cannot be null.");
        else
            content_.append("activo", activo.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProductoPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProductoPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processProductoPOST(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;

            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    productoAll(): Observable<Productolist[]> {
        let url_ = this.baseUrl + "/api/Producto";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProductoAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProductoAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Productolist[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Productolist[]>;
        }));
    }

    protected processProductoAll(response: HttpResponseBase): Observable<Productolist[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Productolist.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param productos (optional)
     * @return OK
     */
    insertarMultiplesProductos(productos?: Producto[] | undefined): Observable<any> {
        let url_ = this.baseUrl + "/api/Producto/insertar-multiples-productos";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (productos === null || productos === undefined)
            throw new Error("The parameter 'productos' cannot be null.");
        else
            productos.forEach(item_ => content_.append("productos", item_.toString()));

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsertarMultiplesProductos(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsertarMultiplesProductos(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processInsertarMultiplesProductos(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;

            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene el pedido más reciente realizado en el sistema.
     * @return OK
     */
    pedidoReciente(): Observable<PedidoReciente> {
        let url_ = this.baseUrl + "/api/Reportes/pedido-reciente";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPedidoReciente(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPedidoReciente(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PedidoReciente>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PedidoReciente>;
        }));
    }

    protected processPedidoReciente(response: HttpResponseBase): Observable<PedidoReciente> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PedidoReciente.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Internal Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene un resumen de ventas entre dos fechas.
     * @param fechaInicio (optional)
     * @param fechaFin (optional)
     * @return OK
     */
    resumenVentas(fechaInicio?: Date | undefined, fechaFin?: Date | undefined): Observable<ResumenVentas[]> {
        let url_ = this.baseUrl + "/api/Reportes/resumen-ventas?";
        if (fechaInicio === null)
            throw new Error("The parameter 'fechaInicio' cannot be null.");
        else if (fechaInicio !== undefined)
            url_ += "fechaInicio=" + encodeURIComponent(fechaInicio ? "" + fechaInicio.toISOString() : "") + "&";
        if (fechaFin === null)
            throw new Error("The parameter 'fechaFin' cannot be null.");
        else if (fechaFin !== undefined)
            url_ += "fechaFin=" + encodeURIComponent(fechaFin ? "" + fechaFin.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResumenVentas(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResumenVentas(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResumenVentas[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResumenVentas[]>;
        }));
    }

    protected processResumenVentas(response: HttpResponseBase): Observable<ResumenVentas[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ResumenVentas.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene los productos más vendidos en un rango de fechas.
     * @param fechaInicio (optional)
     * @param fechaFin (optional)
     * @param limite (optional)
     * @return OK
     */
    productosMasVendidos(fechaInicio?: Date | undefined, fechaFin?: Date | undefined, limite?: number | undefined): Observable<ProductoMasVendido[]> {
        let url_ = this.baseUrl + "/api/Reportes/productos-mas-vendidos?";
        if (fechaInicio === null)
            throw new Error("The parameter 'fechaInicio' cannot be null.");
        else if (fechaInicio !== undefined)
            url_ += "fechaInicio=" + encodeURIComponent(fechaInicio ? "" + fechaInicio.toISOString() : "") + "&";
        if (fechaFin === null)
            throw new Error("The parameter 'fechaFin' cannot be null.");
        else if (fechaFin !== undefined)
            url_ += "fechaFin=" + encodeURIComponent(fechaFin ? "" + fechaFin.toISOString() : "") + "&";
        if (limite === null)
            throw new Error("The parameter 'limite' cannot be null.");
        else if (limite !== undefined)
            url_ += "limite=" + encodeURIComponent("" + limite) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProductosMasVendidos(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProductosMasVendidos(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductoMasVendido[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductoMasVendido[]>;
        }));
    }

    protected processProductosMasVendidos(response: HttpResponseBase): Observable<ProductoMasVendido[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProductoMasVendido.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene un resumen de ventas por categoría en un rango de fechas.
     * @param fechaInicio (optional)
     * @param fechaFin (optional)
     * @return OK
     */
    ventasPorCategoria(fechaInicio?: Date | undefined, fechaFin?: Date | undefined): Observable<VentasPorCategoria[]> {
        let url_ = this.baseUrl + "/api/Reportes/ventas-por-categoria?";
        if (fechaInicio === null)
            throw new Error("The parameter 'fechaInicio' cannot be null.");
        else if (fechaInicio !== undefined)
            url_ += "fechaInicio=" + encodeURIComponent(fechaInicio ? "" + fechaInicio.toISOString() : "") + "&";
        if (fechaFin === null)
            throw new Error("The parameter 'fechaFin' cannot be null.");
        else if (fechaFin !== undefined)
            url_ += "fechaFin=" + encodeURIComponent(fechaFin ? "" + fechaFin.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVentasPorCategoria(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVentasPorCategoria(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VentasPorCategoria[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VentasPorCategoria[]>;
        }));
    }

    protected processVentasPorCategoria(response: HttpResponseBase): Observable<VentasPorCategoria[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(VentasPorCategoria.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene los clientes más frecuentes del sistema.
     * @param limite (optional)
     * @return OK
     */
    clientesFrecuentes(limite?: number | undefined): Observable<ClienteFrecuente[]> {
        let url_ = this.baseUrl + "/api/Reportes/clientes-frecuentes?";
        if (limite === null)
            throw new Error("The parameter 'limite' cannot be null.");
        else if (limite !== undefined)
            url_ += "limite=" + encodeURIComponent("" + limite) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClientesFrecuentes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClientesFrecuentes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClienteFrecuente[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClienteFrecuente[]>;
        }));
    }

    protected processClientesFrecuentes(response: HttpResponseBase): Observable<ClienteFrecuente[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ClienteFrecuente.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene las notificaciones generadas en el sistema.
     * @return OK
     */
    notificaciones(): Observable<void> {
        let url_ = this.baseUrl + "/api/Reportes/notificaciones";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processNotificaciones(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNotificaciones(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processNotificaciones(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Internal Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional)
     * @return OK
     */
    rolPOST(body?: Rol | undefined): Observable<any> {
        let url_ = this.baseUrl + "/api/Rol";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRolPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRolPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processRolPOST(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;

            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional)
     * @return OK
     */
    rolPUT(id: number, body?: Rol | undefined): Observable<any> {
        let url_ = this.baseUrl + "/api/Rol/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRolPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRolPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processRolPUT(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;

            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    rolDELETE(id: number): Observable<any> {
        let url_ = this.baseUrl + "/api/Rol/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRolDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRolDELETE(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processRolDELETE(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;

            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene la lista de todas las subcategorías.
     * @return OK
     */
    subcategoriaAll(): Observable<Subcategoria[]> {
        let url_ = this.baseUrl + "/api/Subcategoria";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubcategoriaAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubcategoriaAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Subcategoria[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Subcategoria[]>;
        }));
    }

    protected processSubcategoriaAll(response: HttpResponseBase): Observable<Subcategoria[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Subcategoria.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Agrega una nueva subcategoría.
     * @param body (optional)
     * @return Created
     */
    subcategoriaPOST(body?: Subcategoria | undefined): Observable<Subcategoria> {
        let url_ = this.baseUrl + "/api/Subcategoria";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubcategoriaPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubcategoriaPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Subcategoria>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Subcategoria>;
        }));
    }

    protected processSubcategoriaPOST(response: HttpResponseBase): Observable<Subcategoria> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = Subcategoria.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Edita una subcategoría existente.
     * @param body (optional)
     * @return OK
     */
    subcategoriaPUT(id: number, body?: Subcategoria | undefined): Observable<any> {
        let url_ = this.baseUrl + "/api/Subcategoria/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubcategoriaPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubcategoriaPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processSubcategoriaPUT(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;

            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Elimina una subcategoría existente.
     * @return OK
     */
    subcategoriaDELETE(id: number): Observable<any> {
        let url_ = this.baseUrl + "/api/Subcategoria/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubcategoriaDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubcategoriaDELETE(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processSubcategoriaDELETE(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;

            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional)
     * @return OK
     */
    registrar(body?: UsuarioPost | undefined): Observable<any> {
        let url_ = this.baseUrl + "/api/Usuario/Registrar";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegistrar(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegistrar(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processRegistrar(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;

            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;

            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional)
     * @return OK
     */
    iniciarSesion(body?: UsuarioLogin | undefined): Observable<any> {
        let url_ = this.baseUrl + "/api/Usuario/IniciarSesion";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIniciarSesion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIniciarSesion(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processIniciarSesion(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;

            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;

            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional)
     * @return OK
     */
    editarUsuario(body?: UsuarioEditar | undefined): Observable<any> {
        let url_ = this.baseUrl + "/api/Usuario/EditarUsuario";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditarUsuario(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditarUsuario(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processEditarUsuario(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;

            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;

            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    eliminarUsuario(idUsuario: number): Observable<any> {
        let url_ = this.baseUrl + "/api/Usuario/EliminarUsuario/{idUsuario}";
        if (idUsuario === undefined || idUsuario === null)
            throw new Error("The parameter 'idUsuario' must be defined.");
        url_ = url_.replace("{idUsuario}", encodeURIComponent("" + idUsuario));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEliminarUsuario(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEliminarUsuario(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processEliminarUsuario(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;

            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;

            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional)
     * @return OK
     */
    registrarActividad(body?: RegistrarActividadRequest | undefined): Observable<any> {
        let url_ = this.baseUrl + "/api/Usuario/RegistrarActividad";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegistrarActividad(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegistrarActividad(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processRegistrarActividad(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;

            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;

            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    consultarAuditoria(idUsuario: number): Observable<any> {
        let url_ = this.baseUrl + "/api/Usuario/ConsultarAuditoria/{idUsuario}";
        if (idUsuario === undefined || idUsuario === null)
            throw new Error("The parameter 'idUsuario' must be defined.");
        url_ = url_.replace("{idUsuario}", encodeURIComponent("" + idUsuario));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConsultarAuditoria(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConsultarAuditoria(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processConsultarAuditoria(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;

            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;

            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional)
     * @return OK
     */
    solicitarRecuperacion(body?: SolicitudRecuperacion | undefined): Observable<any> {
        let url_ = this.baseUrl + "/api/Usuario/SolicitarRecuperacion";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSolicitarRecuperacion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSolicitarRecuperacion(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processSolicitarRecuperacion(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;

            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;

            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional)
     * @return OK
     */
    cambiarContrasena(body?: CambioContrasena | undefined): Observable<any> {
        let url_ = this.baseUrl + "/api/Usuario/CambiarContrasena";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCambiarContrasena(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCambiarContrasena(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processCambiarContrasena(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;

            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;

            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class CambiarEstadoRequest implements ICambiarEstadoRequest {
    nuevoEstado?: string | undefined;
    idUsuario?: number;

    constructor(data?: ICambiarEstadoRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nuevoEstado = _data["nuevoEstado"];
            this.idUsuario = _data["idUsuario"];
        }
    }

    static fromJS(data: any): CambiarEstadoRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CambiarEstadoRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nuevoEstado"] = this.nuevoEstado;
        data["idUsuario"] = this.idUsuario;
        return data;
    }
}

export interface ICambiarEstadoRequest {
    nuevoEstado?: string | undefined;
    idUsuario?: number;
}

export class CambioContrasena implements ICambioContrasena {
    token?: string | undefined;
    nuevaContrasena?: string | undefined;

    constructor(data?: ICambioContrasena) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
            this.nuevaContrasena = _data["nuevaContrasena"];
        }
    }

    static fromJS(data: any): CambioContrasena {
        data = typeof data === 'object' ? data : {};
        let result = new CambioContrasena();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        data["nuevaContrasena"] = this.nuevaContrasena;
        return data;
    }
}

export interface ICambioContrasena {
    token?: string | undefined;
    nuevaContrasena?: string | undefined;
}

export class CancelarPedidoRequest implements ICancelarPedidoRequest {
    idUsuario?: number;

    constructor(data?: ICancelarPedidoRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.idUsuario = _data["idUsuario"];
        }
    }

    static fromJS(data: any): CancelarPedidoRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CancelarPedidoRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["idUsuario"] = this.idUsuario;
        return data;
    }
}

export interface ICancelarPedidoRequest {
    idUsuario?: number;
}

/** Representa una categoría de productos en el sistema de e-commerce. */
export class Categoria implements ICategoria {
    /** Identificador único de la categoría. */
    idCategoria?: number;
    /** Nombre de la categoría. */
    nombre?: string | undefined;
    /** Descripción de la categoría. */
    descripcion?: string | undefined;
    /** Lista de subcategorías asociadas. */
    subcategorias?: Subcategoria[] | undefined;

    constructor(data?: ICategoria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.idCategoria = _data["idCategoria"];
            this.nombre = _data["nombre"];
            this.descripcion = _data["descripcion"];
            if (Array.isArray(_data["subcategorias"])) {
                this.subcategorias = [] as any;
                for (let item of _data["subcategorias"])
                    this.subcategorias!.push(Subcategoria.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Categoria {
        data = typeof data === 'object' ? data : {};
        let result = new Categoria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["idCategoria"] = this.idCategoria;
        data["nombre"] = this.nombre;
        data["descripcion"] = this.descripcion;
        if (Array.isArray(this.subcategorias)) {
            data["subcategorias"] = [];
            for (let item of this.subcategorias)
                data["subcategorias"].push(item.toJSON());
        }
        return data;
    }
}

/** Representa una categoría de productos en el sistema de e-commerce. */
export interface ICategoria {
    /** Identificador único de la categoría. */
    idCategoria?: number;
    /** Nombre de la categoría. */
    nombre?: string | undefined;
    /** Descripción de la categoría. */
    descripcion?: string | undefined;
    /** Lista de subcategorías asociadas. */
    subcategorias?: Subcategoria[] | undefined;
}

export class CategoriaFiltrado implements ICategoriaFiltrado {
    id_producto?: number;
    producto?: string | undefined;
    descripcion?: string | undefined;
    marca?: string | undefined;
    precio?: number;
    cantidad_disponible?: number;
    unidad_medida?: string | undefined;
    imagen_url?: string | undefined;
    fecha_agregado?: Date;
    activo?: boolean;
    categoria?: string | undefined;
    subcategoria?: string | undefined;
    promedio_resenas?: number | undefined;
    total_resenas?: number;

    constructor(data?: ICategoriaFiltrado) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id_producto = _data["id_producto"];
            this.producto = _data["producto"];
            this.descripcion = _data["descripcion"];
            this.marca = _data["marca"];
            this.precio = _data["precio"];
            this.cantidad_disponible = _data["cantidad_disponible"];
            this.unidad_medida = _data["unidad_medida"];
            this.imagen_url = _data["imagen_url"];
            this.fecha_agregado = _data["fecha_agregado"] ? new Date(_data["fecha_agregado"].toString()) : <any>undefined;
            this.activo = _data["activo"];
            this.categoria = _data["categoria"];
            this.subcategoria = _data["subcategoria"];
            this.promedio_resenas = _data["promedio_resenas"];
            this.total_resenas = _data["total_resenas"];
        }
    }

    static fromJS(data: any): CategoriaFiltrado {
        data = typeof data === 'object' ? data : {};
        let result = new CategoriaFiltrado();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id_producto"] = this.id_producto;
        data["producto"] = this.producto;
        data["descripcion"] = this.descripcion;
        data["marca"] = this.marca;
        data["precio"] = this.precio;
        data["cantidad_disponible"] = this.cantidad_disponible;
        data["unidad_medida"] = this.unidad_medida;
        data["imagen_url"] = this.imagen_url;
        data["fecha_agregado"] = this.fecha_agregado ? this.fecha_agregado.toISOString() : <any>undefined;
        data["activo"] = this.activo;
        data["categoria"] = this.categoria;
        data["subcategoria"] = this.subcategoria;
        data["promedio_resenas"] = this.promedio_resenas;
        data["total_resenas"] = this.total_resenas;
        return data;
    }
}

export interface ICategoriaFiltrado {
    id_producto?: number;
    producto?: string | undefined;
    descripcion?: string | undefined;
    marca?: string | undefined;
    precio?: number;
    cantidad_disponible?: number;
    unidad_medida?: string | undefined;
    imagen_url?: string | undefined;
    fecha_agregado?: Date;
    activo?: boolean;
    categoria?: string | undefined;
    subcategoria?: string | undefined;
    promedio_resenas?: number | undefined;
    total_resenas?: number;
}

/** Detalla los clientes más frecuentes y su actividad en el sistema. */
export class ClienteFrecuente implements IClienteFrecuente {
    /** ID del cliente. */
    idUsuario?: number;
    /** Nombre del cliente. */
    nombre?: string | undefined;
    /** Total de pedidos realizados por el cliente. */
    pedidosRealizados?: number;
    /** Total gastado por el cliente. */
    totalGastado?: number;

    constructor(data?: IClienteFrecuente) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.idUsuario = _data["idUsuario"];
            this.nombre = _data["nombre"];
            this.pedidosRealizados = _data["pedidosRealizados"];
            this.totalGastado = _data["totalGastado"];
        }
    }

    static fromJS(data: any): ClienteFrecuente {
        data = typeof data === 'object' ? data : {};
        let result = new ClienteFrecuente();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["idUsuario"] = this.idUsuario;
        data["nombre"] = this.nombre;
        data["pedidosRealizados"] = this.pedidosRealizados;
        data["totalGastado"] = this.totalGastado;
        return data;
    }
}

/** Detalla los clientes más frecuentes y su actividad en el sistema. */
export interface IClienteFrecuente {
    /** ID del cliente. */
    idUsuario?: number;
    /** Nombre del cliente. */
    nombre?: string | undefined;
    /** Total de pedidos realizados por el cliente. */
    pedidosRealizados?: number;
    /** Total gastado por el cliente. */
    totalGastado?: number;
}

export class CrearPedidoRequest implements ICrearPedidoRequest {
    id_usuario?: number;
    productos?: ProductoPedidoRequest[] | undefined;
    direccionCalle?: string | undefined;
    direccionCiudad?: string | undefined;
    direccionCodigoPostal?: string | undefined;
    direccionPais?: string | undefined;

    constructor(data?: ICrearPedidoRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id_usuario = _data["id_usuario"];
            if (Array.isArray(_data["productos"])) {
                this.productos = [] as any;
                for (let item of _data["productos"])
                    this.productos!.push(ProductoPedidoRequest.fromJS(item));
            }
            this.direccionCalle = _data["direccionCalle"];
            this.direccionCiudad = _data["direccionCiudad"];
            this.direccionCodigoPostal = _data["direccionCodigoPostal"];
            this.direccionPais = _data["direccionPais"];
        }
    }

    static fromJS(data: any): CrearPedidoRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CrearPedidoRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id_usuario"] = this.id_usuario;
        if (Array.isArray(this.productos)) {
            data["productos"] = [];
            for (let item of this.productos)
                data["productos"].push(item.toJSON());
        }
        data["direccionCalle"] = this.direccionCalle;
        data["direccionCiudad"] = this.direccionCiudad;
        data["direccionCodigoPostal"] = this.direccionCodigoPostal;
        data["direccionPais"] = this.direccionPais;
        return data;
    }
}

export interface ICrearPedidoRequest {
    id_usuario?: number;
    productos?: ProductoPedidoRequest[] | undefined;
    direccionCalle?: string | undefined;
    direccionCiudad?: string | undefined;
    direccionCodigoPostal?: string | undefined;
    direccionPais?: string | undefined;
}

export class HistorialEstadoPedido implements IHistorialEstadoPedido {
    idHistorial?: number;
    idPedido?: number;
    estadoAnterior?: string | undefined;
    estadoNuevo?: string | undefined;
    fechaCambio?: Date;
    usuarioResponsable?: string | undefined;

    constructor(data?: IHistorialEstadoPedido) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.idHistorial = _data["idHistorial"];
            this.idPedido = _data["idPedido"];
            this.estadoAnterior = _data["estadoAnterior"];
            this.estadoNuevo = _data["estadoNuevo"];
            this.fechaCambio = _data["fechaCambio"] ? new Date(_data["fechaCambio"].toString()) : <any>undefined;
            this.usuarioResponsable = _data["usuarioResponsable"];
        }
    }

    static fromJS(data: any): HistorialEstadoPedido {
        data = typeof data === 'object' ? data : {};
        let result = new HistorialEstadoPedido();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["idHistorial"] = this.idHistorial;
        data["idPedido"] = this.idPedido;
        data["estadoAnterior"] = this.estadoAnterior;
        data["estadoNuevo"] = this.estadoNuevo;
        data["fechaCambio"] = this.fechaCambio ? this.fechaCambio.toISOString() : <any>undefined;
        data["usuarioResponsable"] = this.usuarioResponsable;
        return data;
    }
}

export interface IHistorialEstadoPedido {
    idHistorial?: number;
    idPedido?: number;
    estadoAnterior?: string | undefined;
    estadoNuevo?: string | undefined;
    fechaCambio?: Date;
    usuarioResponsable?: string | undefined;
}

export class MetodoPago implements IMetodoPago {
    idMetodoPago?: number;
    nombre?: string | undefined;

    constructor(data?: IMetodoPago) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.idMetodoPago = _data["idMetodoPago"];
            this.nombre = _data["nombre"];
        }
    }

    static fromJS(data: any): MetodoPago {
        data = typeof data === 'object' ? data : {};
        let result = new MetodoPago();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["idMetodoPago"] = this.idMetodoPago;
        data["nombre"] = this.nombre;
        return data;
    }
}

export interface IMetodoPago {
    idMetodoPago?: number;
    nombre?: string | undefined;
}

export class Pago implements IPago {
    idPago?: number;
    idMetodoPago?: number;
    metodoPago?: string | undefined;
    monto?: number;
    fecha?: Date;

    constructor(data?: IPago) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.idPago = _data["idPago"];
            this.idMetodoPago = _data["idMetodoPago"];
            this.metodoPago = _data["metodoPago"];
            this.monto = _data["monto"];
            this.fecha = _data["fecha"] ? new Date(_data["fecha"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): Pago {
        data = typeof data === 'object' ? data : {};
        let result = new Pago();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["idPago"] = this.idPago;
        data["idMetodoPago"] = this.idMetodoPago;
        data["metodoPago"] = this.metodoPago;
        data["monto"] = this.monto;
        data["fecha"] = this.fecha ? this.fecha.toISOString() : <any>undefined;
        return data;
    }
}

export interface IPago {
    idPago?: number;
    idMetodoPago?: number;
    metodoPago?: string | undefined;
    monto?: number;
    fecha?: Date;
}

/** Representa un pedido realizado por un cliente. */
export class Pedido implements IPedido {
    id_pedido?: number;
    nombre_pedido?: string | undefined;
    cliente?: string | undefined;
    fecha_pedido?: Date;
    metodo_pago?: string | undefined;
    estado?: string | undefined;
    email?: string | undefined;
    teléfono?: string | undefined;
    direccion_envio?: string | undefined;
    subtotal?: string | undefined;
    gran_total?: string | undefined;
    imagenes_productos?: string | undefined;
    cantidad_total?: number;

    constructor(data?: IPedido) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id_pedido = _data["id_pedido"];
            this.nombre_pedido = _data["nombre_pedido"];
            this.cliente = _data["cliente"];
            this.fecha_pedido = _data["fecha_pedido"] ? new Date(_data["fecha_pedido"].toString()) : <any>undefined;
            this.metodo_pago = _data["metodo_pago"];
            this.estado = _data["estado"];
            this.email = _data["email"];
            this.teléfono = _data["teléfono"];
            this.direccion_envio = _data["direccion_envio"];
            this.subtotal = _data["subtotal"];
            this.gran_total = _data["gran_total"];
            this.imagenes_productos = _data["imagenes_productos"];
            this.cantidad_total = _data["cantidad_total"];
        }
    }

    static fromJS(data: any): Pedido {
        data = typeof data === 'object' ? data : {};
        let result = new Pedido();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id_pedido"] = this.id_pedido;
        data["nombre_pedido"] = this.nombre_pedido;
        data["cliente"] = this.cliente;
        data["fecha_pedido"] = this.fecha_pedido ? this.fecha_pedido.toISOString() : <any>undefined;
        data["metodo_pago"] = this.metodo_pago;
        data["estado"] = this.estado;
        data["email"] = this.email;
        data["teléfono"] = this.teléfono;
        data["direccion_envio"] = this.direccion_envio;
        data["subtotal"] = this.subtotal;
        data["gran_total"] = this.gran_total;
        data["imagenes_productos"] = this.imagenes_productos;
        data["cantidad_total"] = this.cantidad_total;
        return data;
    }
}

/** Representa un pedido realizado por un cliente. */
export interface IPedido {
    id_pedido?: number;
    nombre_pedido?: string | undefined;
    cliente?: string | undefined;
    fecha_pedido?: Date;
    metodo_pago?: string | undefined;
    estado?: string | undefined;
    email?: string | undefined;
    teléfono?: string | undefined;
    direccion_envio?: string | undefined;
    subtotal?: string | undefined;
    gran_total?: string | undefined;
    imagenes_productos?: string | undefined;
    cantidad_total?: number;
}

/** Genera un reporte del pedido más reciente realizado en el sistema. */
export class PedidoReciente implements IPedidoReciente {
    /** ID del pedido. */
    idPedido?: number;
    /** Total del pedido. */
    total?: number;
    /** Fecha en la que se realizó el pedido. */
    fechaPedido?: Date;
    /** Estado del pedido. */
    estado?: string | undefined;
    /** Nombre del usuario que realizó el pedido. */
    usuarioNombre?: string | undefined;
    /** Email del usuario. */
    usuarioEmail?: string | undefined;

    constructor(data?: IPedidoReciente) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.idPedido = _data["idPedido"];
            this.total = _data["total"];
            this.fechaPedido = _data["fechaPedido"] ? new Date(_data["fechaPedido"].toString()) : <any>undefined;
            this.estado = _data["estado"];
            this.usuarioNombre = _data["usuarioNombre"];
            this.usuarioEmail = _data["usuarioEmail"];
        }
    }

    static fromJS(data: any): PedidoReciente {
        data = typeof data === 'object' ? data : {};
        let result = new PedidoReciente();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["idPedido"] = this.idPedido;
        data["total"] = this.total;
        data["fechaPedido"] = this.fechaPedido ? this.fechaPedido.toISOString() : <any>undefined;
        data["estado"] = this.estado;
        data["usuarioNombre"] = this.usuarioNombre;
        data["usuarioEmail"] = this.usuarioEmail;
        return data;
    }
}

/** Genera un reporte del pedido más reciente realizado en el sistema. */
export interface IPedidoReciente {
    /** ID del pedido. */
    idPedido?: number;
    /** Total del pedido. */
    total?: number;
    /** Fecha en la que se realizó el pedido. */
    fechaPedido?: Date;
    /** Estado del pedido. */
    estado?: string | undefined;
    /** Nombre del usuario que realizó el pedido. */
    usuarioNombre?: string | undefined;
    /** Email del usuario. */
    usuarioEmail?: string | undefined;
}

export class ProblemDetails implements IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        return data;
    }
}

export interface IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;
}

/** Representa un producto disponible en el e-commerce. */
export class Producto implements IProducto {
    /** Identificador único del producto. */
    id_producto?: number;
    /** Nombre del producto. */
    nombre?: string | undefined;
    /** Descripción detallada del producto. */
    descripcion?: string | undefined;
    /** Identificador de la categoría a la que pertenece el producto. */
    categoria_id?: number;
    /** Identificador de la subcategoría a la que pertenece el producto. */
    subcategoria_id?: number | undefined;
    /** Marca del producto. */
    marca?: string | undefined;
    /** Precio del producto. */
    precio?: number;
    /** Cantidad disponible en inventario. */
    cantidad_disponible?: number;
    /** Unidad de medida del producto. */
    unidad_medida?: string | undefined;
    /** Imagen del producto. */
    imagen_url?: string | undefined;
    /** Fecha en que el producto fue agregado al inventario. */
    fecha_agregado?: Date;
    /** Indica si el producto está activo. */
    activo?: boolean;

    constructor(data?: IProducto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id_producto = _data["id_producto"];
            this.nombre = _data["nombre"];
            this.descripcion = _data["descripcion"];
            this.categoria_id = _data["categoria_id"];
            this.subcategoria_id = _data["subcategoria_id"];
            this.marca = _data["marca"];
            this.precio = _data["precio"];
            this.cantidad_disponible = _data["cantidad_disponible"];
            this.unidad_medida = _data["unidad_medida"];
            this.imagen_url = _data["imagen_url"];
            this.fecha_agregado = _data["fecha_agregado"] ? new Date(_data["fecha_agregado"].toString()) : <any>undefined;
            this.activo = _data["activo"];
        }
    }

    static fromJS(data: any): Producto {
        data = typeof data === 'object' ? data : {};
        let result = new Producto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id_producto"] = this.id_producto;
        data["nombre"] = this.nombre;
        data["descripcion"] = this.descripcion;
        data["categoria_id"] = this.categoria_id;
        data["subcategoria_id"] = this.subcategoria_id;
        data["marca"] = this.marca;
        data["precio"] = this.precio;
        data["cantidad_disponible"] = this.cantidad_disponible;
        data["unidad_medida"] = this.unidad_medida;
        data["imagen_url"] = this.imagen_url;
        data["fecha_agregado"] = this.fecha_agregado ? this.fecha_agregado.toISOString() : <any>undefined;
        data["activo"] = this.activo;
        return data;
    }
}

/** Representa un producto disponible en el e-commerce. */
export interface IProducto {
    /** Identificador único del producto. */
    id_producto?: number;
    /** Nombre del producto. */
    nombre?: string | undefined;
    /** Descripción detallada del producto. */
    descripcion?: string | undefined;
    /** Identificador de la categoría a la que pertenece el producto. */
    categoria_id?: number;
    /** Identificador de la subcategoría a la que pertenece el producto. */
    subcategoria_id?: number | undefined;
    /** Marca del producto. */
    marca?: string | undefined;
    /** Precio del producto. */
    precio?: number;
    /** Cantidad disponible en inventario. */
    cantidad_disponible?: number;
    /** Unidad de medida del producto. */
    unidad_medida?: string | undefined;
    /** Imagen del producto. */
    imagen_url?: string | undefined;
    /** Fecha en que el producto fue agregado al inventario. */
    fecha_agregado?: Date;
    /** Indica si el producto está activo. */
    activo?: boolean;
}

/** Resumen de productos más vendidos en un rango de fechas. */
export class ProductoMasVendido implements IProductoMasVendido {
    /** ID del producto. */
    idProducto?: number;
    /** Nombre del producto. */
    productoNombre?: string | undefined;
    /** Cantidad total vendida del producto. */
    cantidadVendida?: number;
    /** Ingresos generados por el producto. */
    ingresos?: number;

    constructor(data?: IProductoMasVendido) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.idProducto = _data["idProducto"];
            this.productoNombre = _data["productoNombre"];
            this.cantidadVendida = _data["cantidadVendida"];
            this.ingresos = _data["ingresos"];
        }
    }

    static fromJS(data: any): ProductoMasVendido {
        data = typeof data === 'object' ? data : {};
        let result = new ProductoMasVendido();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["idProducto"] = this.idProducto;
        data["productoNombre"] = this.productoNombre;
        data["cantidadVendida"] = this.cantidadVendida;
        data["ingresos"] = this.ingresos;
        return data;
    }
}

/** Resumen de productos más vendidos en un rango de fechas. */
export interface IProductoMasVendido {
    /** ID del producto. */
    idProducto?: number;
    /** Nombre del producto. */
    productoNombre?: string | undefined;
    /** Cantidad total vendida del producto. */
    cantidadVendida?: number;
    /** Ingresos generados por el producto. */
    ingresos?: number;
}

export class ProductoPedidoRequest implements IProductoPedidoRequest {
    id_producto?: number;
    cantidad?: number;

    constructor(data?: IProductoPedidoRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id_producto = _data["id_producto"];
            this.cantidad = _data["cantidad"];
        }
    }

    static fromJS(data: any): ProductoPedidoRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ProductoPedidoRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id_producto"] = this.id_producto;
        data["cantidad"] = this.cantidad;
        return data;
    }
}

export interface IProductoPedidoRequest {
    id_producto?: number;
    cantidad?: number;
}

export class Productoid implements IProductoid {
    id_producto?: number;
    nombre?: string | undefined;
    descripcion?: string | undefined;
    categoria_id?: number;
    subcategoria_id?: number;
    marca?: string | undefined;
    precio?: number;
    cantidad_disponible?: number;
    unidad_medida?: string | undefined;
    imagen_url?: string | undefined;
    fecha_agregado?: Date;
    activo?: boolean;

    constructor(data?: IProductoid) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id_producto = _data["id_producto"];
            this.nombre = _data["nombre"];
            this.descripcion = _data["descripcion"];
            this.categoria_id = _data["categoria_id"];
            this.subcategoria_id = _data["subcategoria_id"];
            this.marca = _data["marca"];
            this.precio = _data["precio"];
            this.cantidad_disponible = _data["cantidad_disponible"];
            this.unidad_medida = _data["unidad_medida"];
            this.imagen_url = _data["imagen_url"];
            this.fecha_agregado = _data["fecha_agregado"] ? new Date(_data["fecha_agregado"].toString()) : <any>undefined;
            this.activo = _data["activo"];
        }
    }

    static fromJS(data: any): Productoid {
        data = typeof data === 'object' ? data : {};
        let result = new Productoid();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id_producto"] = this.id_producto;
        data["nombre"] = this.nombre;
        data["descripcion"] = this.descripcion;
        data["categoria_id"] = this.categoria_id;
        data["subcategoria_id"] = this.subcategoria_id;
        data["marca"] = this.marca;
        data["precio"] = this.precio;
        data["cantidad_disponible"] = this.cantidad_disponible;
        data["unidad_medida"] = this.unidad_medida;
        data["imagen_url"] = this.imagen_url;
        data["fecha_agregado"] = this.fecha_agregado ? this.fecha_agregado.toISOString() : <any>undefined;
        data["activo"] = this.activo;
        return data;
    }
}

export interface IProductoid {
    id_producto?: number;
    nombre?: string | undefined;
    descripcion?: string | undefined;
    categoria_id?: number;
    subcategoria_id?: number;
    marca?: string | undefined;
    precio?: number;
    cantidad_disponible?: number;
    unidad_medida?: string | undefined;
    imagen_url?: string | undefined;
    fecha_agregado?: Date;
    activo?: boolean;
}

export class Productolist implements IProductolist {
    id_producto?: number;
    producto_nombre?: string | undefined;
    producto_descripcion?: string | undefined;
    marca?: string | undefined;
    precio?: number;
    cantidad_disponible?: number;
    unidad_medida?: string | undefined;
    imagen_url?: string | undefined;
    fecha_agregado?: Date;
    activo?: boolean;
    categoria_nombre?: string | undefined;
    categoria_descripcion?: string | undefined;
    subcategoria_nombre?: string | undefined;
    subcategoria_descripcion?: string | undefined;

    constructor(data?: IProductolist) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id_producto = _data["id_producto"];
            this.producto_nombre = _data["producto_nombre"];
            this.producto_descripcion = _data["producto_descripcion"];
            this.marca = _data["marca"];
            this.precio = _data["precio"];
            this.cantidad_disponible = _data["cantidad_disponible"];
            this.unidad_medida = _data["unidad_medida"];
            this.imagen_url = _data["imagen_url"];
            this.fecha_agregado = _data["fecha_agregado"] ? new Date(_data["fecha_agregado"].toString()) : <any>undefined;
            this.activo = _data["activo"];
            this.categoria_nombre = _data["categoria_nombre"];
            this.categoria_descripcion = _data["categoria_descripcion"];
            this.subcategoria_nombre = _data["subcategoria_nombre"];
            this.subcategoria_descripcion = _data["subcategoria_descripcion"];
        }
    }

    static fromJS(data: any): Productolist {
        data = typeof data === 'object' ? data : {};
        let result = new Productolist();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id_producto"] = this.id_producto;
        data["producto_nombre"] = this.producto_nombre;
        data["producto_descripcion"] = this.producto_descripcion;
        data["marca"] = this.marca;
        data["precio"] = this.precio;
        data["cantidad_disponible"] = this.cantidad_disponible;
        data["unidad_medida"] = this.unidad_medida;
        data["imagen_url"] = this.imagen_url;
        data["fecha_agregado"] = this.fecha_agregado ? this.fecha_agregado.toISOString() : <any>undefined;
        data["activo"] = this.activo;
        data["categoria_nombre"] = this.categoria_nombre;
        data["categoria_descripcion"] = this.categoria_descripcion;
        data["subcategoria_nombre"] = this.subcategoria_nombre;
        data["subcategoria_descripcion"] = this.subcategoria_descripcion;
        return data;
    }
}

export interface IProductolist {
    id_producto?: number;
    producto_nombre?: string | undefined;
    producto_descripcion?: string | undefined;
    marca?: string | undefined;
    precio?: number;
    cantidad_disponible?: number;
    unidad_medida?: string | undefined;
    imagen_url?: string | undefined;
    fecha_agregado?: Date;
    activo?: boolean;
    categoria_nombre?: string | undefined;
    categoria_descripcion?: string | undefined;
    subcategoria_nombre?: string | undefined;
    subcategoria_descripcion?: string | undefined;
}

export class RegistrarActividadRequest implements IRegistrarActividadRequest {
    idUsuario?: number;
    accion?: string | undefined;

    constructor(data?: IRegistrarActividadRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.idUsuario = _data["idUsuario"];
            this.accion = _data["accion"];
        }
    }

    static fromJS(data: any): RegistrarActividadRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RegistrarActividadRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["idUsuario"] = this.idUsuario;
        data["accion"] = this.accion;
        return data;
    }
}

export interface IRegistrarActividadRequest {
    idUsuario?: number;
    accion?: string | undefined;
}

export class RegistrarPagoRequest implements IRegistrarPagoRequest {
    idPedido?: number;
    idMetodoPago?: number;
    monto?: number;

    constructor(data?: IRegistrarPagoRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.idPedido = _data["idPedido"];
            this.idMetodoPago = _data["idMetodoPago"];
            this.monto = _data["monto"];
        }
    }

    static fromJS(data: any): RegistrarPagoRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RegistrarPagoRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["idPedido"] = this.idPedido;
        data["idMetodoPago"] = this.idMetodoPago;
        data["monto"] = this.monto;
        return data;
    }
}

export interface IRegistrarPagoRequest {
    idPedido?: number;
    idMetodoPago?: number;
    monto?: number;
}

/** Representa un resumen de las ventas realizadas en un rango de fechas. */
export class ResumenVentas implements IResumenVentas {
    /** Fecha de los pedidos. */
    fecha?: Date;
    /** Total de pedidos realizados en la fecha. */
    totalPedidos?: number;
    /** Total de ingresos generados en la fecha. */
    ingresos?: number;

    constructor(data?: IResumenVentas) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fecha = _data["fecha"] ? new Date(_data["fecha"].toString()) : <any>undefined;
            this.totalPedidos = _data["totalPedidos"];
            this.ingresos = _data["ingresos"];
        }
    }

    static fromJS(data: any): ResumenVentas {
        data = typeof data === 'object' ? data : {};
        let result = new ResumenVentas();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fecha"] = this.fecha ? this.fecha.toISOString() : <any>undefined;
        data["totalPedidos"] = this.totalPedidos;
        data["ingresos"] = this.ingresos;
        return data;
    }
}

/** Representa un resumen de las ventas realizadas en un rango de fechas. */
export interface IResumenVentas {
    /** Fecha de los pedidos. */
    fecha?: Date;
    /** Total de pedidos realizados en la fecha. */
    totalPedidos?: number;
    /** Total de ingresos generados en la fecha. */
    ingresos?: number;
}

export class Rol implements IRol {
    nombreRol?: string | undefined;
    descripcion?: string | undefined;

    constructor(data?: IRol) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nombreRol = _data["nombreRol"];
            this.descripcion = _data["descripcion"];
        }
    }

    static fromJS(data: any): Rol {
        data = typeof data === 'object' ? data : {};
        let result = new Rol();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nombreRol"] = this.nombreRol;
        data["descripcion"] = this.descripcion;
        return data;
    }
}

export interface IRol {
    nombreRol?: string | undefined;
    descripcion?: string | undefined;
}

export class SolicitudRecuperacion implements ISolicitudRecuperacion {
    email?: string | undefined;

    constructor(data?: ISolicitudRecuperacion) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): SolicitudRecuperacion {
        data = typeof data === 'object' ? data : {};
        let result = new SolicitudRecuperacion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        return data;
    }
}

export interface ISolicitudRecuperacion {
    email?: string | undefined;
}

/** Representa una subcategoría de productos en el sistema de e-commerce. */
export class Subcategoria implements ISubcategoria {
    /** Identificador único de la subcategoría. */
    id_subcategoria?: number;
    /** Nombre de la subcategoría. */
    nombre?: string | undefined;
    /** Descripción de la subcategoría. */
    descripcion?: string | undefined;
    /** Identificador de la categoría principal de esta subcategoría. */
    idCategoria?: number;

    constructor(data?: ISubcategoria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id_subcategoria = _data["id_subcategoria"];
            this.nombre = _data["nombre"];
            this.descripcion = _data["descripcion"];
            this.idCategoria = _data["idCategoria"];
        }
    }

    static fromJS(data: any): Subcategoria {
        data = typeof data === 'object' ? data : {};
        let result = new Subcategoria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id_subcategoria"] = this.id_subcategoria;
        data["nombre"] = this.nombre;
        data["descripcion"] = this.descripcion;
        data["idCategoria"] = this.idCategoria;
        return data;
    }
}

/** Representa una subcategoría de productos en el sistema de e-commerce. */
export interface ISubcategoria {
    /** Identificador único de la subcategoría. */
    id_subcategoria?: number;
    /** Nombre de la subcategoría. */
    nombre?: string | undefined;
    /** Descripción de la subcategoría. */
    descripcion?: string | undefined;
    /** Identificador de la categoría principal de esta subcategoría. */
    idCategoria?: number;
}

/** Representa un cliente en el sistema de e-commerce. */
export class UsuarioEditar implements IUsuarioEditar {
    idUsuario?: number;
    nombre?: string | undefined;
    dni?: string | undefined;
    email?: string | undefined;
    telefono?: string | undefined;
    direccionCalle?: string | undefined;
    direccionCiudad?: string | undefined;
    direccionCodigoPostal?: string | undefined;
    direccionPais?: string | undefined;

    constructor(data?: IUsuarioEditar) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.idUsuario = _data["idUsuario"];
            this.nombre = _data["nombre"];
            this.dni = _data["dni"];
            this.email = _data["email"];
            this.telefono = _data["telefono"];
            this.direccionCalle = _data["direccionCalle"];
            this.direccionCiudad = _data["direccionCiudad"];
            this.direccionCodigoPostal = _data["direccionCodigoPostal"];
            this.direccionPais = _data["direccionPais"];
        }
    }

    static fromJS(data: any): UsuarioEditar {
        data = typeof data === 'object' ? data : {};
        let result = new UsuarioEditar();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["idUsuario"] = this.idUsuario;
        data["nombre"] = this.nombre;
        data["dni"] = this.dni;
        data["email"] = this.email;
        data["telefono"] = this.telefono;
        data["direccionCalle"] = this.direccionCalle;
        data["direccionCiudad"] = this.direccionCiudad;
        data["direccionCodigoPostal"] = this.direccionCodigoPostal;
        data["direccionPais"] = this.direccionPais;
        return data;
    }
}

/** Representa un cliente en el sistema de e-commerce. */
export interface IUsuarioEditar {
    idUsuario?: number;
    nombre?: string | undefined;
    dni?: string | undefined;
    email?: string | undefined;
    telefono?: string | undefined;
    direccionCalle?: string | undefined;
    direccionCiudad?: string | undefined;
    direccionCodigoPostal?: string | undefined;
    direccionPais?: string | undefined;
}

export class UsuarioLogin implements IUsuarioLogin {
    email?: string | undefined;
    contrasena?: string | undefined;
    googleLogin?: boolean;

    constructor(data?: IUsuarioLogin) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.contrasena = _data["contrasena"];
            this.googleLogin = _data["googleLogin"];
        }
    }

    static fromJS(data: any): UsuarioLogin {
        data = typeof data === 'object' ? data : {};
        let result = new UsuarioLogin();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["contrasena"] = this.contrasena;
        data["googleLogin"] = this.googleLogin;
        return data;
    }
}

export interface IUsuarioLogin {
    email?: string | undefined;
    contrasena?: string | undefined;
    googleLogin?: boolean;
}

export class UsuarioPost implements IUsuarioPost {
    nombre?: string | undefined;
    email?: string | undefined;
    contrasena?: string | undefined;
    dni?: string | undefined;
    googleRegistro?: boolean;

    constructor(data?: IUsuarioPost) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nombre = _data["nombre"];
            this.email = _data["email"];
            this.contrasena = _data["contrasena"];
            this.dni = _data["dni"];
            this.googleRegistro = _data["googleRegistro"];
        }
    }

    static fromJS(data: any): UsuarioPost {
        data = typeof data === 'object' ? data : {};
        let result = new UsuarioPost();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nombre"] = this.nombre;
        data["email"] = this.email;
        data["contrasena"] = this.contrasena;
        data["dni"] = this.dni;
        data["googleRegistro"] = this.googleRegistro;
        return data;
    }
}

export interface IUsuarioPost {
    nombre?: string | undefined;
    email?: string | undefined;
    contrasena?: string | undefined;
    dni?: string | undefined;
    googleRegistro?: boolean;
}

/** Resumen de ventas por categoría en un rango de fechas. */
export class VentasPorCategoria implements IVentasPorCategoria {
    /** ID de la categoría. */
    idCategoria?: number;
    /** Nombre de la categoría. */
    categoriaNombre?: string | undefined;
    /** Cantidad total de productos vendidos en la categoría. */
    productosVendidos?: number;
    /** Total de ingresos generados por la categoría. */
    ingresos?: number;

    constructor(data?: IVentasPorCategoria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.idCategoria = _data["idCategoria"];
            this.categoriaNombre = _data["categoriaNombre"];
            this.productosVendidos = _data["productosVendidos"];
            this.ingresos = _data["ingresos"];
        }
    }

    static fromJS(data: any): VentasPorCategoria {
        data = typeof data === 'object' ? data : {};
        let result = new VentasPorCategoria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["idCategoria"] = this.idCategoria;
        data["categoriaNombre"] = this.categoriaNombre;
        data["productosVendidos"] = this.productosVendidos;
        data["ingresos"] = this.ingresos;
        return data;
    }
}

/** Resumen de ventas por categoría en un rango de fechas. */
export interface IVentasPorCategoria {
    /** ID de la categoría. */
    idCategoria?: number;
    /** Nombre de la categoría. */
    categoriaNombre?: string | undefined;
    /** Cantidad total de productos vendidos en la categoría. */
    productosVendidos?: number;
    /** Total de ingresos generados por la categoría. */
    ingresos?: number;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}
